<h1> 5 Reasons Why You Should Start Using Rust for Personal Projects</h1>

<p>
    When one master's student at the University of Helsinki was not able to get his hands on one of the UNIX versions for his personal computer, he started his side project. He wanted to build a kernel that ran on his PC. Linus Torvalds'  side-project as you may know was Linux, which is the most popular operating system in the world and currently runs approximately on 1 billion devices.


</p>
<br/> 
<p>
    Steve Wozniak, co-founder of Apple, was toying with computers in his basement when Jobs discovered and convinced him to make money off of his creations. These are just two famous stories. There are many more where the side-project started something interesting, something big, something game-changing, or at least resulted in a good job offer. In this post, I'll try to convince you why you should do side-projects and why you should do them with Rust.
</p>
<br/>

<h2>Importance of Personal Projects</h2>
<p>
    Person side-projects convey three important values. First, it's the best way to learn new technologies, tools, frameworks. Only way you can retain some knowledge from recently learned material is to do some project using newly acquired knowledge. It allows you to experiment, test out ideas, and practice the implementation of those ideas. I personally came to a firm conclusion that I can't say that I understand technology if I haven't done personal implementation of it.
    
</P>
<br>
<p>
    Second, it's a form of signaling. Signaling is an import part of the successful job search and career advancement. If you were an economist probably you don't need further clarification what signaling is. However, I assume majority of you are not so I'll give a quick tour of the signaling part of the <a href="https://en.wikipedia.org/wiki/Contract_theory">contract theory.</a>

</p>
<br>
<p>
    Signaling is the way how one party (namely <i>agent</i>) dispatches the information about itself to another acting party (namely <i>principal</i>). In the job market this can be seen as an attempt by the potential candidate to showcase their ability to the potential employer. For example, your bachelor's degree (if you have one) is a form of signaling. It shows that for at least four years you worked hard, managed to pass the required class, and hopefully attained knowledge.
</p>

<br>

<p>
    Side projects or portfolio projects are also form of signaling. They convey massage to the potential hiring managers that you can show initiative. You can take ownership of the project and work on it independently. It also demonstrates that you have a genuine interest in a field and desire to learn. Often students and people looking for their first developer roles are highly encouraged to work on personal projects.
</p>

<br>

<p>
    Third, it's a great way to network and make interesting connections. I personally connected with several developers who have contributed to my projects or I contributed to theirs. This are meaningful connections, because it's voluntarily. You choose with whom you want to work on a project or task, you can find people with the same interest within interest.
</p>

<br>

<h2>How Rust is Used by Developers</h2>

<p>
Recently JetBrains published <a href="https://www.jetbrains.com/lp/devecosystem-2020/rust/">the developer survey for 2020 about Rust programming language </a>. It was asking why developers chose to use Rust, how they used Rust, what kind of projects they worked with Rust, and if they interact with other languages and other people. It's worth mention that big majority of developers (67%) use Rust for personal projects/hobbies and 80% of them have been using for less than six months.

</p>
<br/>
<center><img src="https://i.imgur.com/spOIQ1U.png" alternative="Rust Usage"><p>
    <i>How Developers use Rust</i>
</p></center>
<br>
<p>
I'm personally happy to see these numbers. Foremost because this is a organic programming language growth path. People start trying new things, building pet projects, get hooked and then try to convince their employers to use those technologies, or even go and build their companies using those technologies.
</p>

<br>
<p>
    The fact that the majority of developers have not been with Rust for more than a year also indicates that language is in an early stage and still needs to mature. Getting started with Rust now will give you a frontline seat for the senior roles when Big names will start looking for the experienced Rust developers. And believe me, the way language is progressing and gaining popularity that time is not that far away.
</p>

<br/>
<p>
    Statistical distribution of what kind of projects are developed in Rust also hints that Rust is a multipurpose programming language. Rust's not only a systems programming language as usually it's advertised. Yes, it is prominently used for systems programming (56%) the frequency of its usage for Web (44%) and Network (32%) is not that far. People are even developing libraries for Machine Learning and working on game engines.
</p>
<br/>
<center><img src="https://i.imgur.com/dy8JM0G.png" alternative="Project Types" height=330><p>
    <i>Project Types developed with Rust</i>
</p></center>

<br/>
<p>
    In summary, we see that the popularity of Rust is on the rise. Developers are experimenting with various libraries and the community is growing every day. Rust goes beyond being just a systems programming language as people are discovering the advantages of including Rust in various ways in their projects.
</p>
<br/>

<h2>
Now, Why Rust?
</h2>

<br/>
<p>
    We examined how Rust is used and saw the multiple directions it's growing and gaining momentum. However, the question still stands. Why Rust? Why you should use Rust? What are eminent features that are alluring developers like a flower attracts bees?
</p>

<br/>

<p>
    Instead of just listing personal opinions I decided to do the following. Ask more experienced Rust developers why they chose Rust and list personal opinions. The question I asked was simple: <i>"What is your elevator pitch for Rust?"</i>. My question got a lot's of responses and stimulated some discussion on Rust's user forum. I handpicked the most interesting replies but if you want you can read through the whole feed <a href="https://users.rust-lang.org/t/what-is-you-elevator-pitch-for-rust/61713/9">here</a>.
</p>
<br/>
    <center><img src="https://www.pinclipart.com/picdir/big/173-1736275_explain-alarmed-ferris-convention-rust-lang-clipart.png" width=300/><p><i>Rust Crab Ferris</i></p></center>
</br>
<p>
    To answer above asked questions I'm going to review following five argument of why you should start using Rust for personal side-projects:
    <br>
    <ol type="1">
<li> Zero-cost abstraction</li>
<li> Immutable and Private by default</li>
<li> Full Experience with Cargo and Rust Compiler</li>
<li> Safety first! no dangling pointers, no memory leaks, and no race conditions</ul>
<li> Rust is not JAL (Just Another Language)</li></ol>
</p>

<br/>
<h3>Zero-Cost Abstraction</h3>
<p>
    You pay only for what you use. The runtime is based on what features you use for your program. What does this mean? For example, in Java or C#, every time you abstract some code it adds some overhead to your program. Because both languages have garbage collectors your extra layer of code needs to be cleaned after you are done using it. This can significantly slow down your program. In Rust, high-level APIs will directly compile into machine code and can have as good performance as if you'd written lower-level code.
</p>
<br/>

<h3>Immutable and Private by Default</h3>
<p>
    When you define variables in Rust they are immutable by default. If you want the variable to be modifiable you need to explicitly state that by using <code>mut</code> keyword. The same goes for the data access modifiers. If you don't state that any field, function, struct, enum, or mod is public its access level is inherently limited to the local scope. Similar to what Java and C# does when you set class or function to <code>private</code>.
</p>
<br/>
<p>
    What's the advantage of this? - A reduction in human error. Popular philosophy about how to set access modifiers is to maximize data protection. For example, if you know a field or function will not be used outside of the class where it's defined it should always remain private. When data is being modified or accessed where it shouldn't this can cause major bugs. Private by default pushes developers to be more conscious of their program design choices and helps to faster detect bugs.
</p>

<br/>
<h3>Cargo and Compiler</h3>
<p>
    When you set up Rust, you not only get Rust the programming language, you get a full environment. Rust comes with <code>cargo</code>, a user-friendly package manager. Cargo gives ease of managing dependencies and setting up build configurations. With only a handful number of commands, you'll be able to create projects, run projects, test them, and even upload to the <a href="crates.io">crates.io</a> where other Rust libraries and packages live.
</p>
    <br/>
    <p>
        Rust also comes with an amazing compiler. One of the first pieces of advice given to me when I started using Rust was not to fight the compiler. Instead, listen to it. Rust compiler utilizes LLVM's decades of optimization. However, besides that, it's very verbose and descriptive of what went wrong. It also suggests potential fixes and alternative approaches developers may consider to overcome given errors during compilation. If your code compiles it's highly likely that it will run without errors.
</p>

<br/>

<h3>Safety First!</h3>
<p>
    The core philosophy of the Rust language is to keep it safe without sacrificing performance. It may sound counterintuitive when you hear this first time (at least it was for me), but it's true. We already mentioned that Rust has no garbage collector. Instead, Rust uses what's called <i>lifetimes.</i> This not only allows code to run fast, but it also guarantees that no unused allocated memory lives in the program when its lifecycle is over. This exterminates the problems known to C developers like memory leaks and dangling pointers.
</p>  
<br/>
<p>
    Rust handles concurrent and parallel program design problems fearlessly. As Chapter 16 of Rust's official Book says:
    <ul> <i>"By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem."</i></ul>

    If you want to learn more about how Rust solves this problem I'd suggest reading above mentioned <a href="https://doc.rust-lang.org/book/ch17-00-concurrency.html">Chapter 16: Fearless Concurrency</a>
</p>

<br/>
<h3>Rust isn't AJL (Another Programming Language)</h3>

<p>
    There are so many new programming languages getting born and getting hyped and then dying out namelessly. But not Rust. Graydon Hoare and the team at Mozilla gave much thought to the language design to solve many issues other popular languages have. This attracted lots of developers. Thoughtful conversations, suggestions, and contributions bestowed the language's growth in the right direction. Rust's community is very welcoming and offers immense support to the newcomers. The Rust's <a href="https://www.reddit.com/r/rust/">Reddit</a>, <a href="https://discord.com/invite/rust-lang-community">Discord channel</a>, and <a href="https://users.rust-lang.org/">Rust forum</a> are amazing places to connect with other Rusteceans, ask for help, or seek advice. So I'll ask you:

    <br/>
     <center><h4>For the next side-project try Rust!</h4></center>
</p>

<br/><br/><br/>
